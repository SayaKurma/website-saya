<!DOCTYPE html>
<html lang="id">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Permainan UNO Modern dengan AlphaZero</title>
<script src="https://cdn.tailwindcss.com"></script>
<script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<script>
tailwind.config = {
  darkMode: 'class',
  theme: {
    extend: {
      colors: {
        dark: '#0f172a',
        darker: '#020617',
        primary: '#3b82f6',
        secondary: '#1e293b',
        primaryDark: '#facc15',
      },
      fontFamily: {
        sans: ['Inter', '-apple-system', 'BlinkMacSystemFont', 'Segoe UI', 'Roboto', 'sans-serif'],
        poppins: ['Poppins', 'sans-serif'],
      }
    }
  }
}
</script>
<style>
@import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap');
:root {
  --primary-color: #3b82f6;
  --primary-hover: #2563eb;
  --dark-text: #334155;
  --primary-dark: #facc15;
  --primary-dark-hover: #eab308;
}
body {
  transition: background-color 0.5s ease, color 0.5s ease;
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  background-color: #f3f4f6;
  color: #334155;
}
body.dark {
  font-family: 'Poppins', sans-serif;
  background-color: #0f172a;
  color: #e2e8f0;
}
.game-container {
  max-width: 90vw;
  margin: auto;
  min-height: calc(100vh - 2rem);
  background: rgba(255, 255, 255, 0.9);
  backdrop-filter: blur(20px);
  border: 1px solid rgba(59, 130, 246, 0.2);
  border-radius: 12px;
  padding: 1.5rem;
  transition: background-color 0.5s ease, border-color 0.5s ease;
}
body.dark .game-container {
  background: rgba(30, 41, 59, 0.9);
  border: 1px solid rgba(250, 204, 21, 0.2);
}
.card {
  width: 70px;
  height: 100px;
  border-radius: 10px;
  display: flex;
  justify-content: center;
  align-items: center;
  cursor: pointer;
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);
  position: relative;
  border: 2px solid #ffffff;
  font-family: 'Poppins', sans-serif;
  background-size: cover;
  background-position: center;
}
.card:focus {
  outline: 3px solid var(--primary-color);
  outline-offset: 2px;
}
body.dark .card:focus {
  outline: 3px solid var(--primary-dark);
}
.card::before {
  content: '';
  position: absolute;
  top: -2px;
  left: -2px;
  right: -2px;
  bottom: -2px;
  background: linear-gradient(45deg, rgba(59, 130, 246, 0.4), transparent);
  border-radius: 10px;
  z-index: -1;
}
body.dark .card::before {
  background: linear-gradient(45deg, rgba(250, 204, 21, 0.4), transparent);
}
.card:hover, .card:focus {
  transform: translateY(-10px) scale(1.05);
  box-shadow: 0 12px 30px rgba(0, 0, 0, 0.3);
}
.card.selected {
  transform: translateY(-15px) scale(1.1);
  box-shadow: 0 0 0 3px var(--primary-color), 0 15px 30px rgba(0, 0, 0, 0.3);
  animation: selectedPulse 2s infinite;
}
body.dark .card.selected {
  box-shadow: 0 0 0 3px var(--primary-dark), 0 15px 30px rgba(0, 0, 0, 0.3);
}
@keyframes selectedPulse {
  0%, 100% {
    box-shadow: 0 0 0 3px var(--primary-color), 0 15px 30px rgba(0, 0, 0, 0.3);
  }
  50% {
    box-shadow: 0 0 0 6px rgba(59, 130, 246, 0.6), 0 15px 30px rgba(0, 0, 0, 0.3);
  }
}
body.dark .card.selected {
  animation: selectedPulseDark 2s infinite;
}
@keyframes selectedPulseDark {
  0%, 100% {
    box-shadow: 0 0 0 3px var(--primary-dark), 0 15px 30px rgba(0, 0, 0, 0.3);
  }
  50% {
    box-shadow: 0 0 0 6px rgba(250, 204, 21, 0.6), 0 15px 30px rgba(0, 0, 0, 0.3);
  }
}
.card-back {
  background: linear-gradient(135deg, #b71c1c 0%, #d32f2f 100%);
  position: relative;
  overflow: hidden;
}
body.dark .card-back {
  background: linear-gradient(135deg, #d32f2f 0%, #f57c00 100%);
}
.card-back::after {
  content: 'UNO';
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%) rotate(-20deg);
  font-family: 'Poppins', sans-serif;
  font-size: 1rem;
  color: #ffffff;
  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.4);
}
.game-center {
  background: rgba(255, 255, 255, 0.25);
  backdrop-filter: blur(10px);
  border-radius: 15px;
  padding: 1.5rem;
  display: flex;
  flex-direction: row;
  align-items: center;
  gap: 4rem;
  justify-content: center;
  border: 1px solid rgba(59, 130, 246, 0.2);
}
body.dark .game-center {
  background: rgba(30, 41, 59, 0.25);
  border: 1px solid rgba(250, 204, 21, 0.2);
}
.draw-pile {
  background: linear-gradient(135deg, #00897b 0%, #00695c 100%);
  border: 2px dashed rgba(255, 255, 255, 0.7);
}
body.dark .draw-pile {
  background: linear-gradient(135deg, #00695c 0%, #004d40 100%);
}
.draw-pile:hover, .draw-pile:focus {
  background: linear-gradient(135deg, #009688 0%, #00796b 100%);
  transform: scale(1.05);
}
body.dark .draw-pile:hover, body.dark .draw-pile:focus {
  background: linear-gradient(135deg, #00796b 0%, #005b4f 100%);
}
.game-stats {
  background: rgba(255, 255, 255, 0.25);
  backdrop-filter: blur(10px);
  border-radius: 12px;
  padding: 1rem;
  border: 1px solid rgba(59, 130, 246, 0.2);
}
body.dark .game-stats {
  background: rgba(30, 41, 59, 0.25);
  border: 1px solid rgba(250, 204, 21, 0.2);
}
.player-area {
  background: rgba(255, 255, 255, 0.15);
  backdrop-filter: blur(10px);
  border-radius: 12px;
  border: 1px solid rgba(59, 130, 246, 0.2);
  padding: 1rem;
}
body.dark .player-area {
  background: rgba(30, 41, 59, 0.15);
  border: 1px solid rgba(250, 204, 21, 0.2);
}
.btn-primary {
  background-color: var(--primary-color);
  color: white;
  transition: all 0.3s ease;
  position: relative;
  overflow: hidden;
  border-radius: 9999px;
  font-family: 'Poppins', sans-serif;
  font-weight: 600;
}
body.dark .btn-primary {
  background-color: var(--primary-dark);
  color: #0f172a;
}
.btn-primary:hover:not(:disabled), .btn-primary:focus {
  background-color: var(--primary-hover);
  transform: translateY(-3px);
  box-shadow: 0 10px 20px rgba(59, 130, 246, 0.3);
}
body.dark .btn-primary:hover:not(:disabled), body.dark .btn-primary:focus {
  background-color: var(--primary-dark-hover);
  box-shadow: 0 10px 20px rgba(250, 204, 21, 0.3);
}
.btn-primary::after {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  width: 300px;
  height: 300px;
  background-color: rgba(255, 255, 255, 0.2);
  border-radius: 50%;
  transform: translate(-50%, -50%) scale(0);
  transition: transform 0.5s;
}
.btn-primary:active::after {
  transform: translate(-50%, -50%) scale(1);
  transition: 0s;
}
.btn-uno {
  background: linear-gradient(135deg, #d32f2f 0%, #f57c00 100%);
  color: #ffffff;
  animation: unoPulse 1.5s infinite;
  box-shadow: 0 4px 15px rgba(211, 47, 47, 0.5);
  border-radius: 9999px;
  font-family: 'Poppins', sans-serif;
  font-weight: 600;
}
body.dark .btn-uno {
  background: linear-gradient(135deg, var(--primary-dark), #eab308);
}
@keyframes unoPulse {
  0%, 100% {
    transform: scale(1);
  }
  50% {
    transform: scale(1.1);
  }
}
.message-modal {
  background: rgba(0, 0, 0, 0.85);
  backdrop-filter: blur(5px);
}
.message-content {
  background: linear-gradient(135deg, var(--primary-color), var(--primary-hover));
  border-radius: 15px;
  box-shadow: 0 15px 30px rgba(0, 0, 0, 0.4);
}
body.dark .message-content {
  background: linear-gradient(135deg, var(--primary-dark), var(--primary-dark-hover));
}
.color-btn {
  width: 50px;
  height: 50px;
  border-radius: 8px;
  cursor: pointer;
  transition: transform 0.2s ease;
  border: 2px solid #ffffff;
}
.color-btn[data-color="red"] {
  background-color: #D40000;
}
.color-btn[data-color="yellow"] {
  background-color: #FFCC00;
}
.color-btn[data-color="green"] {
  background-color: #2CA05A;
}
.color-btn[data-color="blue"] {
  background-color: #2A7FFF;
}
.color-btn:hover, .color-btn:focus {
  transform: scale(1.1);
  outline: 3px solid var(--primary-color);
}
body.dark .color-btn:hover, body.dark .color-btn:focus {
  outline: 3px solid var(--primary-dark);
}
.theme-toggle {
  transition: all 0.3s ease;
  border-radius: 9999px;
  padding: 0.5rem;
}
.theme-toggle:hover {
  transform: scale(1.2);
}
body.dark .theme-toggle {
  background-color: #020617;
}
body.dark .theme-toggle:hover {
  background-color: #1e293b;
}
body.dark .theme-toggle i {
  color: var(--primary-dark);
}
.fade-in {
  animation: fadeIn 0.8s ease-in;
}
@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}
.card-draw-animation {
  animation: slideAndFade 0.5s ease-out forwards;
}
@keyframes slideAndFade {
  0% {
    transform: translate(var(--draw-x, 0), var(--draw-y, 0)) scale(1);
    opacity: 0;
  }
  100% {
    transform: translate(0, 0) scale(1);
    opacity: 1;
  }
}
@media (min-width: 641px) {
  .card {
    width: 90px;
    height: 130px;
  }
  .card-back::after {
    font-size: 1.2rem;
  }
  .game-center {
    padding: 2rem;
    gap: 6rem;
  }
  .player-area {
    padding: 1.5rem;
  }
  .game-stats {
    padding: 1.5rem;
  }
  .color-btn {
    width: 60px;
    height: 60px;
  }
}
@media (min-width: 1024px) {
  .card {
    width: 110px;
    height: 160px;
  }
  .card-back::after {
    font-size: 1.5rem;
  }
  .game-container {
    max-width: 80vw;
    min-height: calc(100vh - 4rem);
  }
  .game-center {
    padding: 3rem;
    gap: 8rem;
  }
  .player-area {
    padding: 2rem;
  }
  .game-stats {
    padding: 2rem;
  }
  .color-btn {
    width: 70px;
    height: 70px;
  }
}
.card-move {
  animation: moveToDiscard 0.5s ease-out forwards;
}
@keyframes moveToDiscard {
  0% {
    transform: translate(0, 0) scale(1);
    opacity: 1;
  }
  100% {
    transform: translate(var(--discard-x, 0), var(--discard-y, -200px)) scale(1);
    opacity: 0;
  }
}
.card-move-computer {
  animation: moveToDiscardComputer 0.5s ease-out forwards;
}
@keyframes moveToDiscardComputer {
  0% {
    transform: translate(0, 0) scale(1);
    opacity: 1;
  }
  100% {
    transform: translate(var(--discard-x, 0), var(--discard-y, 200px)) scale(1);
    opacity: 0;
  }
}
.title-glow {
  text-shadow: 0 0 20px rgba(59, 130, 246, 0.6);
}
body.dark .title-glow {
  text-shadow: 0 0 20px rgba(250, 204, 21, 0.6);
}
</style>
</head>
<body class="min-h-screen flex flex-col bg-gray-50 text-gray-800 transition-colors duration-300">
<main class="flex-grow flex flex-col game-container mx-2 my-4 rounded-xl fade-in" role="main" aria-label="Area permainan UNO">
  <div class="flex justify-end p-4">
    <button id="themeToggle" class="p-2 rounded-full bg-gray-200 hover:bg-gray-300 transition-all theme-toggle">
      <i class="fas fa-sun text-yellow-500"></i>
    </button>
  </div>
  <div class="player-area mx-2 my-2 p-2" role="region" aria-label="Tangan komputer">
    <div id="computer-hand" class="flex justify-center flex-wrap gap-2 min-h-[120px] items-center"></div>
  </div>
  <div class="flex-grow flex justify-center items-center p-2">
    <div class="game-center relative" role="region" aria-label="Area tengah permainan">
      <div class="text-center">
        <div id="discard-pile" class="card" role="img" aria-label="Tumpukan buangan"></div>
      </div>
      <div class="text-center">
        <div id="draw-pile" class="card draw-pile cursor-pointer" role="button" aria-label="Tumpukan ambil kartu" tabindex="0">
          <div class="text-white text-3xl">?</div>
        </div>
      </div>
    </div>
  </div>
  <div class="player-area mx-2 my-2 p-2" role="region" aria-label="Tangan pemain">
    <div id="player-hand" class="flex justify-center flex-wrap gap-2 min-h-[120px] items-center"></div>
  </div>
</main>
<div class="game-stats mx-2 my-2 py-2 px-4 flex flex-wrap justify-center gap-3" role="region" aria-label="Status permainan">
  <button id="uno-btn" class="btn-uno text-white px-4 py-2 rounded-full font-semibold hidden transition-all" aria-label="Panggil UNO" tabindex="0">
    🔥 UNO!
  </button>
</div>
<div id="message" class="message-modal fixed inset-0 flex items-center justify-center z-50 hidden" role="dialog" aria-live="assertive">
  <div class="message-content text-white px-6 py-4 mx-4 max-w-md w-full text-center">
    <p id="message-text" class="text-lg md:text-xl mb-4 font-semibold title-glow"></p>
    <div id="message-buttons" class="flex justify-center gap-3">
      <button id="play-again-btn" class="btn-primary text-white px-4 py-2 rounded-full font-semibold hover:bg-gray-100 transition-all hidden" aria-label="Main lagi" tabindex="0">
        Main Lagi
      </button>
      <button id="back-btn" class="bg-white text-purple-800 px-4 py-2 rounded-full font-semibold hover:bg-gray-100 transition-all hidden" aria-label="Kembali ke menu utama" tabindex="0">
        Kembali
      </button>
      <button id="close-message" class="bg-white text-purple-800 px-4 py-2 rounded-full font-semibold hover:bg-gray-100 transition-all" aria-label="Lanjutkan permainan" tabindex="0">
        Lanjut
      </button>
    </div>
  </div>
</div>
<div id="color-chooser" class="message-modal fixed inset-0 flex items-center justify-center z-50 hidden" role="dialog" aria-label="Pilih warna untuk kartu Wild">
  <div class="message-content text-white px-6 py-4 mx-4 max-w-md w-full text-center">
    <p class="text-lg md:text-xl mb-4 font-semibold title-glow">Pilih warna</p>
    <div class="flex justify-center gap-3">
      <div class="color-btn" data-color="red" role="button" aria-label="Pilih warna merah" tabindex="0"></div>
      <div class="color-btn" data-color="blue" role="button" aria-label="Pilih warna biru" tabindex="0"></div>
      <div class="color-btn" data-color="green" role="button" aria-label="Pilih warna hijau" tabindex="0"></div>
      <div class="color-btn" data-color="yellow" role="button" aria-label="Pilih warna kuning" tabindex="0"></div>
    </div>
  </div>
</div>
<script>
// Theme toggle functionality
const themeToggle = document.getElementById('themeToggle');
const themeIcon = themeToggle.querySelector('i');
themeToggle.addEventListener('click', () => {
  document.body.classList.toggle('dark');
  if (document.body.classList.contains('dark')) {
    themeIcon.classList.remove('fa-sun', 'text-yellow-500');
    themeIcon.classList.add('fa-moon', 'text-primaryDark');
  } else {
    themeIcon.classList.remove('fa-moon', 'text-primaryDark');
    themeIcon.classList.add('fa-sun', 'text-yellow-500');
  }
});

// Card image mappings
const cardImages = {
  'red_0': 'https://unocardinfo.victorhomedia.com/graphics/uno_card-red0.png',
  'red_1': 'https://unocardinfo.victorhomedia.com/graphics/uno_card-red1.png',
  'red_2': 'https://unocardinfo.victorhomedia.com/graphics/uno_card-red2.png',
  'red_3': 'https://unocardinfo.victorhomedia.com/graphics/uno_card-red3.png',
  'red_4': 'https://unocardinfo.victorhomedia.com/graphics/uno_card-red4.png',
  'red_5': 'https://unocardinfo.victorhomedia.com/graphics/uno_card-red5.png',
  'red_6': 'https://unocardinfo.victorhomedia.com/graphics/uno_card-red6.png',
  'red_7': 'https://unocardinfo.victorhomedia.com/graphics/uno_card-red7.png',
  'red_8': 'https://unocardinfo.victorhomedia.com/graphics/uno_card-red8.png',
  'red_9': 'https://unocardinfo.victorhomedia.com/graphics/uno_card-red9.png',
  'red_Skip': 'https://unocardinfo.victorhomedia.com/graphics/uno_card-redskip.png',
  'red_Reverse': 'https://unocardinfo.victorhomedia.com/graphics/uno_card-redreverse.png',
  'red_Draw2': 'https://unocardinfo.victorhomedia.com/graphics/uno_card-reddraw2.png',
  'blue_0': 'https://unocardinfo.victorhomedia.com/graphics/uno_card-blue0.png',
  'blue_1': 'https://unocardinfo.victorhomedia.com/graphics/uno_card-blue1.png',
  'blue_2': 'https://unocardinfo.victorhomedia.com/graphics/uno_card-blue2.png',
  'blue_3': 'https://unocardinfo.victorhomedia.com/graphics/uno_card-blue3.png',
  'blue_4': 'https://unocardinfo.victorhomedia.com/graphics/uno_card-blue4.png',
  'blue_5': 'https://unocardinfo.victorhomedia.com/graphics/uno_card-blue5.png',
  'blue_6': 'https://unocardinfo.victorhomedia.com/graphics/uno_card-blue6.png',
  'blue_7': 'https://unocardinfo.victorhomedia.com/graphics/uno_card-blue7.png',
  'blue_8': 'https://unocardinfo.victorhomedia.com/graphics/uno_card-blue8.png',
  'blue_9': 'https://unocardinfo.victorhomedia.com/graphics/uno_card-blue9.png',
  'blue_Skip': 'https://unocardinfo.victorhomedia.com/graphics/uno_card-blueskip.png',
  'blue_Reverse': 'https://unocardinfo.victorhomedia.com/graphics/uno_card-bluereverse.png',
  'blue_Draw2': 'https://unocardinfo.victorhomedia.com/graphics/uno_card-bluedraw2.png',
  'green_0': 'https://unocardinfo.victorhomedia.com/graphics/uno_card-green0.png',
  'green_1': 'https://unocardinfo.victorhomedia.com/graphics/uno_card-green1.png',
  'green_2': 'https://unocardinfo.victorhomedia.com/graphics/uno_card-green2.png',
  'green_3': 'https://unocardinfo.victorhomedia.com/graphics/uno_card-green3.png',
  'green_4': 'https://unocardinfo.victorhomedia.com/graphics/uno_card-green4.png',
  'green_5': 'https://unocardinfo.victorhomedia.com/graphics/uno_card-green5.png',
  'green_6': 'https://unocardinfo.victorhomedia.com/graphics/uno_card-green6.png',
  'green_7': 'https://unocardinfo.victorhomedia.com/graphics/uno_card-green7.png',
  'green_8': 'https://unocardinfo.victorhomedia.com/graphics/uno_card-green8.png',
  'green_9': 'https://unocardinfo.victorhomedia.com/graphics/uno_card-green9.png',
  'green_Skip': 'https://unocardinfo.victorhomedia.com/graphics/uno_card-greenskip.png',
  'green_Reverse': 'https://unocardinfo.victorhomedia.com/graphics/uno_card-greenreverse.png',
  'green_Draw2': 'https://unocardinfo.victorhomedia.com/graphics/uno_card-greendraw2.png',
  'yellow_0': 'https://unocardinfo.victorhomedia.com/graphics/uno_card-yellow0.png',
  'yellow_1': 'https://unocardinfo.victorhomedia.com/graphics/uno_card-yellow1.png',
  'yellow_2': 'https://unocardinfo.victorhomedia.com/graphics/uno_card-yellow2.png',
  'yellow_3': 'https://unocardinfo.victorhomedia.com/graphics/uno_card-yellow3.png',
  'yellow_4': 'https://unocardinfo.victorhomedia.com/graphics/uno_card-yellow4.png',
  'yellow_5': 'https://unocardinfo.victorhomedia.com/graphics/uno_card-yellow5.png',
  'yellow_6': 'https://unocardinfo.victorhomedia.com/graphics/uno_card-yellow6.png',
  'yellow_7': 'https://unocardinfo.victorhomedia.com/graphics/uno_card-yellow7.png',
  'yellow_8': 'https://unocardinfo.victorhomedia.com/graphics/uno_card-yellow8.png',
  'yellow_9': 'https://unocardinfo.victorhomedia.com/graphics/uno_card-yellow9.png',
  'yellow_Skip': 'https://unocardinfo.victorhomedia.com/graphics/uno_card-yellowskip.png',
  'yellow_Reverse': 'https://unocardinfo.victorhomedia.com/graphics/uno_card-yellowreverse.png',
  'yellow_Draw2': 'https://unocardinfo.victorhomedia.com/graphics/uno_card-yellowdraw2.png',
  'wild_Wild': 'https://unocardinfo.victorhomedia.com/graphics/uno_card-wildchange.png',
  'wild_Wild_Draw4': 'https://unocardinfo.victorhomedia.com/graphics/uno_card-wilddraw4.png'
};

// Game state variables
let deck = [];
let discardPile = [];
let playerHand = [];
let computerHand = [];
let currentPlayer = 'player';
let currentColor = '';
let currentValue = '';
let selectedCardIndex = -1;
let unoCalled = false;
let isDrawing = false;
let playerHasOneCard = false;
let waitingForPlayerConfirmation = false;
let opponentActionCardCount = 0;
let playerColorChoices = { red: 0, blue: 0, green: 0, yellow: 0 };

const computerHandEl = document.getElementById('computer-hand');
const playerHandEl = document.getElementById('player-hand');
const discardPileEl = document.getElementById('discard-pile');
const drawPileEl = document.getElementById('draw-pile');
const unoBtn = document.getElementById('uno-btn');
const messageEl = document.getElementById('message');
const messageTextEl = document.getElementById('message-text');
const playAgainBtn = document.getElementById('play-again-btn');
const backBtn = document.getElementById('back-btn');
const closeMessageBtn = document.getElementById('close-message');
const colorChooserEl = document.getElementById('color-chooser');
const colorButtons = document.querySelectorAll('.color-btn');
const colors = ['red', 'blue', 'green', 'yellow'];
const values = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'Skip', 'Reverse', 'Draw2'];
const wildCards = ['Wild', 'Wild_Draw4'];

// Neural Network Implementation
class NeuralNetwork {
  constructor() {
    this.weights = [];
    this.biases = [];
    this.layers = [108 + 108 + 4 + 13, 128, 64, 1 + 112]; // Input: deck + hands + color + value, Output: value + policy
    this.initWeights();
  }

  initWeights() {
    for (let i = 0; i < this.layers.length - 1; i++) {
      const w = [];
      for (let j = 0; j < this.layers[i]; j++) {
        const row = [];
        for (let k = 0; k < this.layers[i + 1]; k++) {
          row.push(Math.random() * 0.1 - 0.05);
        }
        w.push(row);
      }
      this.weights.push(w);
      this.biases.push(new Array(this.layers[i + 1]).fill(0));
    }
  }

  relu(x) {
    return Math.max(0, x);
  }

  softmax(x) {
    const max = Math.max(...x);
    const exp = x.map(v => Math.exp(v - max));
    const sum = exp.reduce((a, b) => a + b, 0);
    return exp.map(v => v / sum);
  }

  forward(input) {
    let x = input;
    for (let i = 0; i < this.weights.length; i++) {
      const next = new Array(this.layers[i + 1]).fill(0);
      for (let j = 0; j < this.layers[i]; j++) {
        for (let k = 0; k < this.layers[i + 1]; k++) {
          next[k] += x[j] * this.weights[i][j][k];
        }
      }
      for (let k = 0; k < this.layers[i + 1]; k++) {
        next[k] += this.biases[i][k];
        if (i < this.weights.length - 1) {
          next[k] = this.relu(next[k]);
        }
      }
      x = next;
    }
    const value = x[0];
    const policy = this.softmax(x.slice(1));
    return { value, policy };
  }

  encodeState(state) {
    const input = new Array(this.layers[0]).fill(0);
    const cardMap = {};
    let idx = 0;
    for (const c of colors) {
      for (const v of [...values, ...wildCards]) {
        cardMap[`${c}_${v}`] = idx++;
      }
    }
    for (const card of state.deck) {
      input[cardMap[`${card.color}_${card.value}`]]++;
    }
    for (const card of state.computerHand) {
      input[108 + cardMap[`${card.color}_${card.value}`]]++;
    }
    for (const card of state.playerHand) {
      input[108 + cardMap[`${card.color}_${card.value}`]]++;
    }
    if (state.currentColor) {
      input[216 + colors.indexOf(state.currentColor)] = 1;
    }
    if (state.currentValue) {
      const valIdx = [...values, ...wildCards].indexOf(state.currentValue);
      input[220 + valIdx] = 1;
    }
    return input;
  }
}

const nn = new NeuralNetwork();

// AlphaZero Node
class AlphaZeroNode {
  constructor(state, parent = null, move = null, prior = 0) {
    this.state = state;
    this.parent = parent;
    this.move = move;
    this.children = [];
    this.visits = 0;
    this.valueSum = 0;
    this.prior = prior;
    this.untriedMoves = getPossibleMoves(state.computerHand);
  }
}

// Utility Functions
function debounce(func, wait) {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

function initGame() {
  deck = [];
  discardPile = [];
  playerHand = [];
  computerHand = [];
  currentPlayer = 'player';
  currentColor = '';
  currentValue = '';
  selectedCardIndex = -1;
  unoCalled = false;
  isDrawing = false;
  playerHasOneCard = false;
  waitingForPlayerConfirmation = false;
  opponentActionCardCount = 0;
  playerColorChoices = { red: 0, blue: 0, green: 0, yellow: 0 };
  createDeck();
  shuffleDeck();
  dealCards();
  startFirstTurn();
  updateHands();
  unoBtn.classList.add('hidden');
  colorChooserEl.classList.add('hidden');
  messageEl.classList.add('hidden');
  drawPileEl.removeEventListener('click', handleDraw);
  drawPileEl.removeEventListener('touchstart', handleDraw);
  drawPileEl.addEventListener('click', handleDraw);
  drawPileEl.addEventListener('touchstart', handleDraw);
  drawPileEl.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' || e.key === ' ') {
      e.preventDefault();
      handleDraw(e);
    }
  });
  discardPileEl.removeEventListener('click', handleDiscardClick);
  discardPileEl.removeEventListener('touchstart', handleDiscardClick);
  discardPileEl.addEventListener('click', handleDiscardClick);
  discardPileEl.addEventListener('touchstart', handleDiscardClick);
  discardPileEl.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' || e.key === ' ') {
      e.preventDefault();
      handleDiscardClick(e);
    }
  });
  document.addEventListener('keydown', handleKeyboardNavigation);
}

function createDeck() {
  deck = [];
  for (const color of colors) {
    deck.push({ color, value: '0' });
    for (const value of values.slice(1)) {
      deck.push({ color, value });
      deck.push({ color, value });
    }
  }
  for (const value of wildCards) {
    for (let i = 0; i < 4; i++) {
      deck.push({ color: 'wild', value });
    }
  }
}

function shuffleDeck() {
  for (let i = deck.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [deck[i], deck[j]] = [deck[j], deck[i]];
  }
}

function dealCards() {
  for (let i = 0; i < 7; i++) {
    playerHand.push(deck.pop());
    computerHand.push(deck.pop());
  }
}

function startFirstTurn() {
  let card;
  do {
    card = deck.pop();
  } while (card.color === 'wild');
  discardPile.push(card);
  currentColor = card.color;
  currentValue = card.value;
  updateDiscardPile();
  announce(`Permainan dimulai! Kartu awal: ${card.color} ${card.value}`);
}

function updateHands(newCardIndex = -1) {
  computerHandEl.innerHTML = '';
  for (let i = 0; i < computerHand.length; i++) {
    const cardEl = document.createElement('div');
    cardEl.className = 'card card-back';
    cardEl.setAttribute('aria-hidden', 'true');
    computerHandEl.appendChild(cardEl);
  }
  playerHandEl.innerHTML = '';
  for (let i = 0; i < playerHand.length; i++) {
    const card = playerHand[i];
    const cardEl = document.createElement('div');
    cardEl.className = 'card';
    cardEl.setAttribute('role', 'button');
    cardEl.setAttribute('tabindex', '0');
    cardEl.setAttribute('aria-label', `Kartu ${card.color} ${card.value.replace('_', ' ')}`);
    const imageKey = card.color === 'wild' ? `wild_${card.value}` : `${card.color}_${card.value}`;
    cardEl.style.backgroundImage = `url(${cardImages[imageKey]})`;
    if (i === newCardIndex) {
      const drawRect = drawPileEl.getBoundingClientRect();
      const playerHandRect = playerHandEl.getBoundingClientRect();
      const deltaX = drawRect.left - playerHandRect.left;
      const deltaY = drawRect.top - playerHandRect.top;
      cardEl.style.setProperty('--draw-x', `${deltaX}px`);
      cardEl.style.setProperty('--draw-y', `${deltaY}px`);
      cardEl.classList.add('card-draw-animation');
      setTimeout(() => {
        cardEl.classList.remove('card-draw-animation');
        cardEl.style.removeProperty('--draw-x');
        cardEl.style.removeProperty('--draw-y');
      }, 500);
    }
    cardEl.addEventListener('click', () => selectCard(i));
    cardEl.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        selectCard(i);
      }
    });
    playerHandEl.appendChild(cardEl);
  }
  if (selectedCardIndex >= 0 && selectedCardIndex < playerHand.length) {
    playerHandEl.children[selectedCardIndex].classList.add('selected');
    playerHandEl.children[selectedCardIndex].focus();
  }
  announce(`Tangan Anda: ${playerHand.map(card => `${card.color} ${card.value}`).join(', ')}`);
}

function updateDiscardPile() {
  if (discardPile.length === 0) return;
  const card = discardPile[discardPile.length - 1];
  discardPileEl.innerHTML = '';
  discardPileEl.className = 'card';
  discardPileEl.setAttribute('aria-label', `Kartu di tumpukan buangan: ${card.color} ${card.value.replace('_', ' ')}`);
  const imageKey = card.color === 'wild' ? `wild_${card.value}` : `${card.color}_${card.value}`;
  discardPileEl.style.backgroundImage = `url(${cardImages[imageKey]})`;
  if (currentPlayer === 'player' && ['Skip', 'Reverse', 'Draw2', 'Wild', 'Wild_Draw4'].includes(card.value)) {
    opponentActionCardCount++;
  }
  announce(`Kartu di tumpukan buangan: ${card.color} ${card.value}`);
}

function updateCounts() {
  if (playerHand.length === 1) {
    playerHasOneCard = true;
  } else {
    playerHasOneCard = false;
    unoCalled = false;
    unoBtn.classList.add('hidden');
  }
}

function showUnoButton() {
  if (playerHasOneCard && currentPlayer === 'player') {
    unoBtn.classList.remove('hidden');
    unoBtn.focus();
    announce('Anda memiliki satu kartu! Tekan U untuk memanggil UNO.');
  } else {
    unoBtn.classList.add('hidden');
  }
}

function selectCard(index) {
  if (currentPlayer !== 'player') {
    announce('Bukan giliran Anda!');
    return;
  }
  if (selectedCardIndex >= 0 && selectedCardIndex < playerHand.length) {
    playerHandEl.children[selectedCardIndex].classList.remove('selected');
  }
  selectedCardIndex = index;
  playerHandEl.children[selectedCardIndex].classList.add('selected');
  playerHandEl.children[selectedCardIndex].focus();
  announce(`Kartu yang dipilih: ${playerHand[index].color} ${playerHand[index].value}. Tekan Enter untuk memainkan kartu.`);
}

function handleKeyboardNavigation(e) {
  if (currentPlayer !== 'player') return;
  if (e.key === 'ArrowRight' && selectedCardIndex < playerHand.length - 1) {
    selectCard(selectedCardIndex + 1);
  } else if (e.key === 'ArrowLeft' && selectedCardIndex > 0) {
    selectCard(selectedCardIndex - 1);
  } else if (e.key === 'Enter' && selectedCardIndex >= 0) {
    handleDiscardClick(e);
  } else if (e.key.toLowerCase() === 'u' && playerHand.length === 1) {
    callUno();
  } else if (e.key === 'd') {
    handleDraw(e);
  }
}

function canPlayCard(card) {
  if (card.color === 'wild') return true;
  const topCard = discardPile[discardPile.length - 1];
  if (topCard.color === 'wild') return card.color === currentColor;
  return card.color === topCard.color || card.value === topCard.value;
}

function handleDiscardClick(e) {
  e.preventDefault();
  if (selectedCardIndex === -1 || currentPlayer !== 'player') {
    announce('Pilih kartu terlebih dahulu atau bukan giliran Anda!');
    return;
  }
  const card = playerHand[selectedCardIndex];
  if (!canPlayCard(card)) {
    showMessage('❌ Kartu tidak valid! Pilih warna atau nilai yang cocok.');
    return;
  }
  if (playerHand.length === 1 && !unoCalled) {
    playerMustDraw();
    return;
  }
  const selectedCardEl = playerHandEl.children[selectedCardIndex];
  const discardRect = discardPileEl.getBoundingClientRect();
  const cardRect = selectedCardEl.getBoundingClientRect();
  const deltaX = discardRect.left - cardRect.left;
  const deltaY = discardRect.top - cardRect.top;
  selectedCardEl.style.setProperty('--discard-x', `${deltaX}px`);
  selectedCardEl.style.setProperty('--discard-y', `${deltaY}px`);
  selectedCardEl.classList.add('card-move');
  setTimeout(() => {
    playerHand.splice(selectedCardIndex, 1);
    discardPile.push(card);
    announce(`Anda memainkan kartu ${card.color} ${card.value}`);
    if (card.color === 'wild') {
      showColorChooser();
    } else {
      updateGameStateAfterPlay(card);
      selectedCardIndex = -1;
      updateDiscardPile();
      updateHands();
      updateCounts();
      if (['Skip', 'Reverse', 'Draw2', 'Wild_Draw4'].includes(card.value)) {
        showUnoButton();
      }
      if (playerHand.length === 0) {
        endGame();
        return;
      }
      if (currentPlayer === 'computer') {
        setTimeout(computerTurn, 1000);
      }
    }
  }, 500);
}

function showColorChooser() {
  colorChooserEl.classList.remove('hidden');
  colorButtons[0].focus();
  announce('Pilih warna untuk kartu Wild.');
}

function chooseColor(color) {
  playerColorChoices[color]++;
  currentColor = color;
  colorChooserEl.classList.add('hidden');
  const card = discardPile[discardPile.length - 1];
  announce(`Warna dipilih: ${color}`);
  selectedCardIndex = -1;
  updateDiscardPile();
  updateHands();
  updateCounts();
  updateGameStateAfterPlay(card);
  showUnoButton();
  if (playerHand.length === 0) {
    endGame();
    return;
  }
  if (currentPlayer === 'computer') {
    setTimeout(computerTurn, 1000);
  }
}

const handleDraw = debounce((e) => {
  e.preventDefault();
  if (playerHasOneCard && !unoCalled) {
    playerMustDraw();
    return;
  }
  drawCard();
}, 500);

function drawCard() {
  if (isDrawing || currentPlayer !== 'player') {
    showMessage('⏳ Bukan giliran Anda atau sedang mengambil kartu!');
    return;
  }
  isDrawing = true;
  if (deck.length === 0) {
    reshuffleDeck();
  }
  const card = deck.pop();
  playerHand.push(card);
  announce(`Anda mengambil kartu: ${card.color} ${card.value}`);
  updateHands(playerHand.length - 1);
  if (canPlayCard(card)) {
    selectCard(playerHand.length - 1);
  } else {
    currentPlayer = 'computer';
    updateCounts();
    setTimeout(computerTurn, 1000);
  }
  isDrawing = false;
}

function computerChooseColor() {
  const state = {
    computerHand: [...computerHand],
    playerHand: [...playerHand],
    discardPile: [...discardPile],
    deck: [...deck],
    currentColor,
    currentValue,
    currentPlayer: 'computer'
  };
  const input = nn.encodeState(state);
  const { policy } = nn.forward(input);
  const colorProbs = policy.slice(108, 112);
  let maxProb = -1;
  let bestColor = colors[0];
  colors.forEach((color, i) => {
    if (colorProbs[i] > maxProb) {
      maxProb = colorProbs[i];
      bestColor = color;
    }
  });
  return bestColor;
}

function getPossibleMoves(hand) {
  const moves = [];
  const topCard = discardPile[discardPile.length - 1];
  const currentTopColor = topCard.color === 'wild' ? currentColor : topCard.color;
  for (let i = 0; i < hand.length; i++) {
    const card = hand[i];
    if (canPlayCard(card)) {
      if (card.color === 'wild') {
        colors.forEach(color => {
          moves.push({ type: 'play', cardIndex: i, card, colorChoice: color });
        });
      } else {
        moves.push({ type: 'play', cardIndex: i, card });
      }
    }
  }
  if (moves.length === 0) {
    moves.push({ type: 'draw' });
  }
  return moves;
}

function applyMove(state, move, isComputer) {
  const newState = {
    computerHand: [...state.computerHand],
    playerHand: [...state.playerHand],
    discardPile: [...state.discardPile],
    deck: [...state.deck],
    currentColor: state.currentColor,
    currentValue: state.currentValue,
    currentPlayer: state.currentPlayer
  };
  if (move.type === 'draw') {
    if (newState.deck.length === 0) {
      const topCard = newState.discardPile.pop();
      newState.deck = [...newState.discardPile];
      shuffleDeck();
      newState.discardPile = [topCard];
    }
    const drawnCard = newState.deck.pop();
    (isComputer ? newState.computerHand : newState.playerHand).push(drawnCard);
    newState.currentPlayer = isComputer ? 'player' : 'computer';
    return newState;
  }
  const hand = isComputer ? newState.computerHand : newState.playerHand;
  const card = hand[move.cardIndex];
  newState.discardPile.push(card);
  hand.splice(move.cardIndex, 1);
  if (card.color === 'wild') {
    newState.currentColor = move.colorChoice;
    newState.currentValue = '';
  } else {
    newState.currentColor = card.color;
    newState.currentValue = card.value;
  }
  switch (card.value) {
    case 'Skip':
    case 'Reverse':
      newState.currentPlayer = isComputer ? 'computer' : 'player';
      break;
    case 'Draw2':
      const opponentHand = isComputer ? newState.playerHand : newState.computerHand;
      for (let i = 0; i < 2; i++) {
        if (newState.deck.length === 0) {
          const topCard = newState.discardPile.pop();
          newState.deck = [...newState.discardPile];
          shuffleDeck();
          newState.discardPile = [topCard];
        }
        if (newState.deck.length > 0) {
          opponentHand.push(newState.deck.pop());
        }
      }
      newState.currentPlayer = isComputer ? 'computer' : 'player';
      break;
    case 'Wild_Draw4':
      const opponentHandWild = isComputer ? newState.playerHand : newState.computerHand;
      for (let i = 0; i < 4; i++) {
        if (newState.deck.length === 0) {
          const topCard = newState.discardPile.pop();
          newState.deck = [...newState.discardPile];
          shuffleDeck();
          newState.discardPile = [topCard];
        }
        if (newState.deck.length > 0) {
          opponentHandWild.push(newState.deck.pop());
        }
      }
      newState.currentPlayer = isComputer ? 'computer' : 'player';
      break;
    default:
      newState.currentPlayer = isComputer ? 'player' : 'computer';
      break;
  }
  return newState;
}

function alphaZeroSearch(rootState, iterations) {
  const root = new AlphaZeroNode(rootState);
  const input = nn.encodeState(rootState);
  const { policy } = nn.forward(input);
  const moveMap = {};
  let policyIdx = 0;
  const possibleMoves = getPossibleMoves(rootState.computerHand);
  possibleMoves.forEach((move, i) => {
    if (move.type === 'play') {
      const cardKey = `${move.card.color}_${move.card.value}`;
      moveMap[i] = policyIdx++;
      if (move.card.color === 'wild') {
        colors.forEach(() => policyIdx++);
      }
    } else {
      moveMap[i] = 108;
    }
  });
  possibleMoves.forEach((move, i) => {
    root.children.push(new AlphaZeroNode(applyMove(rootState, move, true), root, move, policy[moveMap[i]]));
  });
  const explorationConstant = 1.0;
  for (let i = 0; i < iterations; i++) {
    let node = root;
    while (node.children.length > 0) {
      node = selectChild(node, explorationConstant);
    }
    const { value } = nn.forward(nn.encodeState(node.state));
    while (node !== null) {
      node.visits++;
      node.valueSum += value;
      node = node.parent;
    }
  }
  let bestChild = null;
  let bestVisits = -1;
  for (const child of root.children) {
    if (child.visits > bestVisits) {
      bestVisits = child.visits;
      bestChild = child;
    }
  }
  return bestChild ? bestChild.move : possibleMoves[0];
}

function selectChild(node, c) {
  let bestScore = -Infinity;
  let bestChild = null;
  const parentVisits = Math.log(node.visits + 1);
  for (const child of node.children) {
    const q = child.visits > 0 ? child.valueSum / child.visits : 0;
    const u = c * child.prior * Math.sqrt(parentVisits) / (1 + child.visits);
    const score = q + u;
    if (score > bestScore) {
      bestScore = score;
      bestChild = child;
    }
  }
  return bestChild;
}

function selfPlay() {
  const gameStates = [];
  const policies = [];
  const outcomes = [];
  let state = {
    computerHand: [],
    playerHand: [],
    discardPile: [],
    deck: [],
    currentColor: '',
    currentValue: '',
    currentPlayer: 'player'
  };
  initGame();
  while (playerHand.length > 0 && computerHand.length > 0) {
    state = {
      computerHand: [...computerHand],
      playerHand: [...playerHand],
      discardPile: [...discardPile],
      deck: [...deck],
      currentColor,
      currentValue,
      currentPlayer
    };
    const input = nn.encodeState(state);
    const { policy } = nn.forward(input);
    const moveProbs = new Array(112).fill(0);
    const possibleMoves = getPossibleMoves(state.computerHand);
    const moveMap = {};
    let policyIdx = 0;
    possibleMoves.forEach((move, i) => {
      if (move.type === 'play') {
        moveMap[i] = policyIdx++;
        if (move.card.color === 'wild') {
          colors.forEach(() => moveProbs[policyIdx++] = policy[policyIdx]);
        }
      } else {
        moveMap[i] = 108;
      }
      moveProbs[moveMap[i]] = policy[moveMap[i]];
    });
    const moveIdx = possibleMoves.reduce((maxIdx, move, i) =>
      moveProbs[moveMap[i]] > moveProbs[moveMap[maxIdx]] ? i : maxIdx, 0);
    const move = possibleMoves[moveIdx];
    gameStates.push(input);
    policies.push(moveProbs);
    state = applyMove(state, move, state.currentPlayer === 'computer');
    computerHand = state.computerHand;
    playerHand = state.playerHand;
    discardPile = state.discardPile;
    deck = state.deck;
    currentColor = state.currentColor;
    currentValue = state.currentValue;
    currentPlayer = state.currentPlayer;
  }
  const outcome = computerHand.length === 0 ? 1 : -1;
  outcomes.push(outcome);
  return { gameStates, policies, outcomes };
}

function trainNeuralNetwork() {
  const { gameStates, policies, outcomes } = selfPlay();
  const learningRate = 0.01;
  for (let i = 0; i < gameStates.length; i++) {
    const input = gameStates[i];
    const targetPolicy = policies[i];
    const targetValue = outcomes[0];
    const { value, policy } = nn.forward(input);
    const valueError = targetValue - value;
    const policyError = targetPolicy.map((t, j) => t - policy[j]);
    let delta = new Array(nn.layers[nn.layers.length - 1]).fill(0);
    delta[0] = valueError;
    for (let j = 0; j < policyError.length; j++) {
      delta[j + 1] = policyError[j];
    }
    for (let l = nn.weights.length - 1; l >= 0; l--) {
      const prevDelta = new Array(nn.layers[l]).fill(0);
      for (let j = 0; j < nn.layers[l]; j++) {
        for (let k = 0; k < nn.layers[l + 1]; k++) {
          nn.weights[l][j][k] += learningRate * input[j] * delta[k];
          nn.biases[l][k] += learningRate * delta[k];
          prevDelta[j] += delta[k] * nn.weights[l][j][k];
        }
      }
      delta = prevDelta.map(d => d > 0 ? d : 0);
      input = nn.forward(input).value > 0 ? input.map(x => x > 0 ? x : 0) : input;
    }
  }
}

function findBestMove() {
  const state = {
    computerHand: [...computerHand],
    playerHand: [...playerHand],
    discardPile: [...discardPile],
    deck: [...deck],
    currentColor,
    currentValue,
    currentPlayer: 'computer'
  };
  const iterations = computerHand.length <= 3 ? 800 : 400;
  return alphaZeroSearch(state, iterations);
}

function computerTurn() {
  if (waitingForPlayerConfirmation) return;
  currentPlayer = 'computer';
  updateCounts();
  const bestMove = findBestMove();
  if (bestMove.type === 'draw') {
    if (deck.length === 0) reshuffleDeck();
    const card = deck.pop();
    computerHand.push(card);
    if (canPlayCard(card)) {
      const cardIndex = computerHand.length - 1;
      const playedCard = computerHand[cardIndex];
      const tempCardEl = document.createElement('div');
      tempCardEl.className = 'card';
      const imageKey = playedCard.color === 'wild' ? `wild_${playedCard.value}` : `${playedCard.color}_${playedCard.value}`;
      tempCardEl.style.backgroundImage = `url(${cardImages[imageKey]})`;
      tempCardEl.setAttribute('aria-label', `Kartu ${playedCard.color} ${playedCard.value.replace('_', ' ')}`);
      computerHandEl.appendChild(tempCardEl);
      const discardRect = discardPileEl.getBoundingClientRect();
      const cardRect = tempCardEl.getBoundingClientRect();
      const deltaX = discardRect.left - cardRect.left;
      const deltaY = discardRect.top - cardRect.top;
      tempCardEl.style.setProperty('--discard-x', `${deltaX}px`);
      tempCardEl.style.setProperty('--discard-y', `${deltaY}px`);
      tempCardEl.classList.add('card-move-computer');
      setTimeout(() => {
        computerHand.splice(cardIndex, 1);
        discardPile.push(playedCard);
        announce(`Komputer memainkan kartu ${playedCard.color} ${playedCard.value}`);
        if (playedCard.color === 'wild') {
          currentColor = computerChooseColor();
          showMessage(`🤖 Komputer memainkan ${playedCard.value.replace('_', ' ')} dan memilih warna ${currentColor}!`);
          updateGameStateAfterPlay(playedCard);
        } else {
          updateGameStateAfterPlay(playedCard);
        }
        updateDiscardPile();
        updateCounts();
        if (computerHand.length === 1) {
          const shouldCallUno = !computerHand.some(card => card.color === 'wild' || card.value === 'Draw2');
          if (shouldCallUno) {
            showMessage('🤖 Komputer memanggil UNO!');
          } else {
            computerMustDraw();
            return;
          }
        }
        if (playerHand.length > 0 && computerHand.length > 0) {
          if (currentPlayer === 'player') {
            updateCounts();
            showUnoButton();
          } else if (!waitingForPlayerConfirmation) {
            setTimeout(computerTurn, 1000);
          }
        } else {
          endGame();
        }
        updateHands();
      }, 500);
    } else {
      if (playerHand.length > 0 && computerHand.length > 0) {
        currentPlayer = 'player';
        updateCounts();
        showUnoButton();
        announce('Giliran Anda!');
      } else {
        endGame();
      }
      updateHands();
    }
  } else {
    const card = bestMove.card;
    const cardIndex = bestMove.cardIndex;
    const tempCardEl = document.createElement('div');
    tempCardEl.className = 'card';
    const imageKey = card.color === 'wild' ? `wild_${card.value}` : `${card.color}_${card.value}`;
    tempCardEl.style.backgroundImage = `url(${cardImages[imageKey]})`;
    tempCardEl.setAttribute('aria-label', `Kartu ${card.color} ${card.value.replace('_', ' ')}`);
    computerHandEl.children[cardIndex].replaceWith(tempCardEl);
    const discardRect = discardPileEl.getBoundingClientRect();
    const cardRect = tempCardEl.getBoundingClientRect();
    const deltaX = discardRect.left - cardRect.left;
    const deltaY = discardRect.top - cardRect.top;
    tempCardEl.style.setProperty('--discard-x', `${deltaX}px`);
    tempCardEl.style.setProperty('--discard-y', `${deltaY}px`);
    tempCardEl.classList.add('card-move-computer');
    setTimeout(() => {
      computerHand.splice(cardIndex, 1);
      discardPile.push(card);
      announce(`Komputer memainkan kartu ${card.color} ${card.value}`);
      if (card.color === 'wild') {
        currentColor = bestMove.colorChoice || computerChooseColor();
        showMessage(`🤖 Komputer memainkan ${card.value.replace('_', ' ')} dan memilih warna ${currentColor}!`);
        updateGameStateAfterPlay(card);
      } else {
        updateGameStateAfterPlay(card);
      }
      updateDiscardPile();
      updateCounts();
      if (computerHand.length === 1) {
        const shouldCallUno = !computerHand.some(card => card.color === 'wild' || card.value === 'Draw2');
        if (shouldCallUno) {
          showMessage('🤖 Komputer memanggil UNO!');
        } else {
          computerMustDraw();
          return;
        }
      }
      if (playerHand.length > 0 && computerHand.length > 0) {
        if (currentPlayer === 'player') {
          updateCounts();
          showUnoButton();
        } else if (!waitingForPlayerConfirmation) {
          setTimeout(computerTurn, 1000);
        }
      } else {
        endGame();
      }
      updateHands();
    }, 500);
  }
}

function updateGameStateAfterPlay(card) {
  if (card.color === 'wild') {
    currentValue = '';
  } else {
    currentColor = card.color;
    currentValue = card.value;
  }
  switch (card.value) {
    case 'Skip':
    case 'Reverse':
      currentPlayer = currentPlayer === 'player' ? 'player' : 'computer';
      announce(currentPlayer === 'player' ? 'Anda memainkan kartu aksi. Giliran Anda lagi.' : 'Komputer memainkan kartu aksi.');
      break;
    case 'Draw2':
      if (currentPlayer === 'player') {
        computerDrawCards(2);
        currentPlayer = 'player';
        announce('Anda memainkan Draw Two. Komputer mengambil 2 kartu.');
      } else {
        playerDrawCards(2);
        currentPlayer = 'computer';
        announce('Komputer memainkan Draw Two. Anda mengambil 2 kartu.');
      }
      break;
    case 'Wild_Draw4':
      if (currentPlayer === 'player') {
        computerDrawCards(4);
        currentPlayer = 'player';
        announce('Anda memainkan Wild Draw Four. Komputer mengambil 4 kartu.');
      } else {
        playerDrawCards(4);
        currentPlayer = 'computer';
        waitingForPlayerConfirmation = true;
        showMessage(`🤖 Komputer memainkan Wild Draw Four dan memilih warna ${currentColor}. Anda mengambil 4 kartu.`);
        announce(`Komputer memainkan Wild Draw Four. Klik Lanjut.`);
      }
      break;
    default:
      currentPlayer = currentPlayer === 'player' ? 'computer' : 'player';
      announce(currentPlayer === 'player' ? 'Giliran Anda!' : 'Giliran komputer.');
      break;
  }
}

function callUno() {
  if (playerHand.length === 1) {
    unoCalled = true;
    unoBtn.classList.add('hidden');
    showMessage('🔥 UNO! Kartu tersisa 1!');
    announce('Anda memanggil UNO!');
  }
}

function playerMustDraw() {
  playerDrawCards(2);
  showMessage('Kamu lupa menyebut UNO! Ambil 2 kartu.');
  announce('Kamu lupa menyebut UNO! Mengambil 2 kartu.');
  selectedCardIndex = -1;
  updateHands();
  updateCounts();
  currentPlayer = 'computer';
  setTimeout(computerTurn, 2000);
}

function computerMustDraw() {
  computerDrawCards(2);
  showMessage('🤖 Komputer lupa memanggil UNO! Mengambil 2 kartu.');
  currentPlayer = 'player';
  announce('Komputer lupa memanggil UNO! Giliran Anda.');
  updateCounts();
  showUnoButton();
}

function playerDrawCards(count) {
  for (let i = 0; i < count; i++) {
    if (deck.length === 0) reshuffleDeck();
    playerHand.push(deck.pop());
    updateHands(playerHand.length - 1);
  }
  updateCounts();
}

function computerDrawCards(count) {
  for (let i = 0; i < count; i++) {
    if (deck.length === 0) reshuffleDeck();
    computerHand.push(deck.pop());
  }
  updateHands();
  updateCounts();
}

function reshuffleDeck() {
  if (discardPile.length <= 1) return;
  const topCard = discardPile.pop();
  deck = discardPile;
  shuffleDeck();
  discardPile = [topCard];
  showMessage('🔄 Dek telah diacak ulang!');
  announce('Dek telah diacak ulang!');
}

function launchConfetti() {
  confetti({
    particleCount: 100,
    spread: 70,
    origin: { y: 0.6 },
    colors: ['#D40000', '#2CA05A', '#2A7FFF', '#FFCC00']
  });
}

function showMessage(text) {
  messageTextEl.textContent = text;
  messageEl.classList.remove('hidden');
  if (text.includes('menang')) {
    playAgainBtn.classList.remove('hidden');
    backBtn.classList.remove('hidden');
    closeMessageBtn.classList.add('hidden');
    launchConfetti();
    playAgainBtn.focus();
  } else {
    playAgainBtn.classList.add('hidden');
    backBtn.classList.add('hidden');
    closeMessageBtn.classList.remove('hidden');
    closeMessageBtn.focus();
  }
  announce(text);
}

function closeMessage() {
  messageEl.classList.add('hidden');
  if (waitingForPlayerConfirmation && currentPlayer === 'computer' && playerHand.length > 0 && computerHand.length > 0) {
    waitingForPlayerConfirmation = false;
    setTimeout(computerTurn, 1000);
  }
  if (selectedCardIndex >= 0 && currentPlayer === 'player' && selectedCardIndex < playerHand.length) {
    playerHandEl.children[selectedCardIndex].focus();
  } else {
    drawPileEl.focus();
  }
}

function endGame() {
  if (playerHand.length === 0) {
    showMessage('🎉 Selamat! Anda menang! 🏆');
  } else if (computerHand.length === 0) {
    showMessage('🤖 Komputer menang! Coba lagi! 💪');
  }
}

function announce(text) {
  const liveRegion = document.createElement('div');
  liveRegion.setAttribute('aria-live', 'polite');
  liveRegion.setAttribute('aria-atomic', 'true');
  liveRegion.setAttribute('style', 'position: absolute; left: -9999px;');
  liveRegion.textContent = text;
  document.body.appendChild(liveRegion);
  setTimeout(() => {
    document.body.removeChild(liveRegion);
  }, 1000);
}

colorButtons.forEach(button => {
  button.addEventListener('click', () => {
    const color = button.getAttribute('data-color');
    chooseColor(color);
  });
  button.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' || e.key === ' ') {
      e.preventDefault();
      const color = button.getAttribute('data-color');
      chooseColor(color);
    }
  });
});

unoBtn.addEventListener('click', callUno);
unoBtn.addEventListener('keydown', (e) => {
  if (e.key === 'Enter' || e.key === ' ') {
    e.preventDefault();
    callUno();
  }
});

playAgainBtn.addEventListener('click', initGame);
playAgainBtn.addEventListener('keydown', (e) => {
  if (e.key === 'Enter' || e.key === ' ') {
    e.preventDefault();
    initGame();
  }
});

backBtn.addEventListener('click', () => {
  window.location.href = 'https://sayakurma.github.io/website-saya/';
});

backBtn.addEventListener('keydown', (e) => {
  if (e.key === 'Enter' || e.key === ' ') {
    e.preventDefault();
    window.location.href = 'https://sayakurma.github.io/website-saya/';
  }
});

closeMessageBtn.addEventListener('click', closeMessage);
closeMessageBtn.addEventListener('keydown', (e) => {
  if (e.key === 'Enter' || e.key === ' ') {
    e.preventDefault();
    closeMessage();
  }
});

// Pre-train neural network
for (let i = 0; i < 10; i++) {
  trainNeuralNetwork();
}

window.addEventListener('load', initGame);
</script>
</body>
</html>